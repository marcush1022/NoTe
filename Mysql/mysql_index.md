#索引index是提高mysql获取数据效率的数据结构

###############################################################################################################################
#mysql InnoDB索引底层数据结构: B+-Tree 
###############################################################################################################################
#动态查找树
主要有二叉查找树, 平衡二叉查找树, 红黑树, B树和B+树, 前三者是典型的二叉树查找结构, 查找的效率O(logN)与树的深度有关, 降低树的深度就可以提高查找效率;
但是在实际的查找过程中, `树的节点存储的数据量有限`, 因为如果节点存储数据量太大的话会退化为节点内部的线性查找; 
`因此当数据的量较大时会导致树的深度较大, 从而导致频繁的磁盘IO; 减少树深度的方法就是采用多叉树(多路查找树)`;
一般地, 索引本身也比较大, 不可能全部存储与内存中, 因此索引以索引文件的形式存储与硬盘上, 索引的查找过程会产生IO消耗, `因此索引的组织结构需要尽可能减少查找过程中的磁盘IO次数`; 
#多路查找树 如B树(B-Tree)
`B树的目的是解决磁盘IO速度慢的问题`;
B树类似红黑树, 与红黑树最大的区别是B树的节点可以有多个子节点, 从几个到几千个, B树的特点: 所有叶节点在同一层, 有j个子节点的节点至少有j-1个关键字, `关键字按递增排序`; 这样降低了树的深度, `因此只需将少量的节点从硬盘读入内存, 提高了查找的效率`; 
数据库系统在设计时, 利用了数据预读的原理, `将一个节点的大小设计为页的大小(4k), 因此每个节点只需要一次磁盘IO就可以载入`;
#B树的变体 B+树(B+-Tree)
`应文件系统的需求产生的一种B树的变体`;
B+树的特点: 
1. `所有的叶节点保存了全部的关键字信息, 以及指向含有这些关键字的记录的指针`; 
2. `叶节点按照关键字的增序排列并链接(数组链接), 链接的目的是提高区间查询性能`;
3. `所有非终端节点可看成索引的部分`, `节点中仅含有其子树根节点中最大(最小)的关键字, B树不是`(B树非终端节点中也包含需要查找的关键字);
#为什么B+树更适合作为操作系统的文件索引和数据库索引?
1. B+树的磁盘IO代价更低: B+树的内部节点没有指向关键字具体信息的指针, 因此其内部结构相对B树更小, 提高IO效率???
2. B+树的查询效率更加稳定: 非终端节点并不是指向文件内容的节点, 而只是叶子节点中关键字的索引, 所以任何关键字的查找必须从根节点到叶子节点, 所有关键字的查询路径相同, 每一个数据的查询效率相当;
数据库使用B+树的主要原因: "`B树在提高磁盘IO效率的同时没有解决元素遍历效率低下的问题`, 而B+树只需要遍历叶子节点就可以实现整个树的遍历, `数据库中基于范围的查询(range query)是比较频繁的`, 而B树不支持这种操作(或者说效率太低); `B+树方便扫库`, `B树只有中序遍历的方法进行扫库`; 比如查5-10之间, B+树首先查到5, 然后顺序直接到10, 串起来就行;"
#总结
`B树: 有序数组+平衡多叉树`
`B+树: 有序数组链表+平衡多叉树`

###############################################################################################################################
#索引
###############################################################################################################################
#索引的目的: 降低查询数据时的磁盘IO次数, 提高查询效率;
#磁盘IO的成本, 磁盘预读: 
磁盘IO比较耗时(`机械运动消耗`), 内存中数据的IO速度大概是磁盘的IO速度的100~100万倍, 磁盘读取依靠机械运动, 分为寻道时间, 旋转延迟和传输时间, 寻道时间是磁臂移动到指定磁道需要的时间, 主流磁盘一般在5ms以下; 旋转延迟是磁盘转速; 传输时间即数据从磁盘读出或写入磁盘的时间, 相对与前两个时间这个可以忽略不计。针对这个问题操作系统进行了优化, `所以当计算机读取一个地址的数据时, 将相邻的数据也读取到内存中, 每次读取的数据称为一页, 内存和磁盘以页为单位交换数据`, 页的大小与操作系统有关;
因此在存储信息时, `应尽量将相关的信息存放在相邻的位置`, 至少在同一柱面或相邻柱面上, 减少磁头的移动次数;
`索引数据结构`: `目的为降低每次查询数据时的磁盘IO次数 (B+树), IO次数取决于树的高度`;
`索引的最左匹配: B+树按照从左到右的顺序建立搜索树`;

#建立索引的原则:
1. `最左匹配原则: mysql会一直右匹配到>, <, between, like就停止匹配`, 例如a=1 and b=2 and c<3 and d=4 `则d用不到索引`;
2. `索引列不能参与计算`: 如from_unixtime(create_time)='2014-01-01'就不能使用索引, 应写成create_time=unix_timestamp('2014-01-01')
3. `=和in可以乱序`, 例如a=1 and b=2 and c=3 建立的(a, b, c)索引可以任意乱序, mysql会自动优化成索引可以识别的形式;
4. 尽量使用扩展索引: 如当前已有索引为a, 若需要(a, b)的索引, 只需修改原来的索引;
5. `尽量选择区分度高的列作为索引`: 区分度公式为`COUNT(DISTINCT COL)/COUNT(*)`表示字段不重复的比例, `比例越大扫描的记录数越少`, 唯一键的区分度就是1, `而一些状态、性别的字段在大数据的情况下区分度可能就是0`。`一般需要JOIN的字段要求0.1以上`, 即平均一条索引扫描10条记录;
6. `多个单列索引和组合索引的效果不同, 当创建了多个单列索引时, 查询优化器会视图选择一个限制最严格(候选记录集数量最小, 最有效率)的索引`, `但即使是限制最严格的单列索引, 其限制能力也远远低于这些列上的组合索引`;
7. `索引并非越多越好`, 因为写入或删除时需要更新索引的信息;

#可以使用索引的SQL:
1. 若字段已建立索引, `求该字段的MAX, MIN时`, 依然会使用索引;
2. `对列进行比较`的表达式可以使用索引, 如>=, <, between;
3. 若col_name建立了索引, 则`col_name is null`可以使用索引;
4. 若where中不只一个条件, 优化器会使用`index merge`进行缩小候选集范围;

`慢查询优化的基本步骤`
0. 设置SQL_NO_CACHE;
1. where单表查, 锁定最小记录返回表, 把查询语句的where应用到表的返回记录最小的表开始查起;
2. explain, 是否与1中的结果一致(从锁定记录最小的表开始查询);
3. order by limit 的sql语句让排序的表优先查;
...

#[高性能MySQL]

`联合索引/复合索引`
联合索引即复合索引, 对于复合索引, `mysql按从左到右的顺序使用索引中的字段`, `查询使用的索引的部分只能是最左的部分`(最左前缀);
例: index(a, b, c)支持a, ab, abc, 但是不支持bc;

`索引的物理存储`
索引本身较大, 不可能全部存储与内存中, 因此索引是`以索引文件的形式存储于磁盘上`;
衡量索引好坏的因素就是查找过程中, 磁盘IO的渐进复杂度, 即`索引的结构组织应尽可能减少查找过程中的磁盘IO次数`;

###############################################################################################################################
#B+树索引: 聚集索引和非聚集索引
###############################################################################################################################
B+树的索引分为`聚集索引（clustered index）和非聚集索引(secondary index)`
1. 聚集索引：聚集索引是每张表的主键建立一个B+树，`叶节点存放整张表的行记录数据`, 每张表只能有一个聚集索引(一个主键);
聚集索引的好处是对于主键的排序查找和范围查找比较方便，叶节点即为要查找的数据;
2. 非聚集索引（或称为辅助索引）：`叶节点不包含行的全部数据`，叶节点除了包含行数据的键值以外，还包含了一个bookmark, 指向哪里可以找到索引的对应的完整的数据;

###############################################################################################################################
#INNODB主键的选择和优化
###############################################################################################################################
`使用innoDB时, 建议使用与业务无关的自增字段作为主键`;
InnoDB使用聚集索引, 数据记录本身存储于主索引的叶子节点上, 这就要求叶子节点中(大小为一个内存页或一个磁盘页)的数据按主键顺序进行存放, 因此当新的数据插入时, `mysql会根据其主键的值将其插入顺序添加到后续位置`, 如果超过页面的装载因子则开辟一个新的页, 这样会形成一个紧凑的索引结构, 近似顺序填满, `插入数据时不需要移动数据`;
若使用非自增主键, `每次插入的位置近似随机`, 每次插入都会随机插入到当前索引页的中间某个位置, 此时`mysql需要移动数据来进行树插入`, 增加了很多开销;

###############################################################################################################################
#不应建立索引的情况
###############################################################################################################################
1. `表中数据量较小`, 建议2000条以下的表不建索引;
2. `字段的区分度较低`;

###############################################################################################################################
#使用联合索引的优势
###############################################################################################################################
联合索引的底层实现依然是B+树, 只是联合索引键值的数量不是一个, 而是>=2, 若联合索引是(a, b), 则键值(1,1),(1,2),(2,1),(2,4),(3,1),(3,2)按(a,b)的顺序进行排序;
`联合索引的一个好处是第二键值基本有序`, 当a相同时，b为升序（降序）, 有时可以省略一次额外的排序操作;
但是不能对b进行查找，如SELECT * FROM TABLE_1 WHERE b = XXX, 因为树中的b是无序的;
对于b=XXX 和 b >XXX AND b <XXX 的情况并不是完全不能使用(a,b)的联合索引；如SELECT COUNT(*) FROM TABLE_1 WHERE b>XXX AND b<XXX 的情况就可以使用(a,b)的b列，因为结果是一个COUNT()的结果; 或者在SELECT b FROM TABLE_1 WHERE b>XXX AND b<XXX