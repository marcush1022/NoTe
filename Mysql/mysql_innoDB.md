#INNODB

Record-level-lock分为3种:
#LOCK_REC_NOT_GAP(Record Lock): 只是锁记录但是不锁记录之前的GAP, RC隔离级别一般使用该锁;
行锁;

#LOCK_GAP(GAP Lock): 只锁住一段范围, 不锁记录本身, 通常表示两个索引记录之间, 或索引上的第一条记录之前, 或最后一条记录之后的锁, 一般在RR级别使用GAP Lock;
间隙锁;

#LOCK_ORDINARY(Next-Key Lock): 包含记录本身及记录之前的GAP, Mysql默认使用RR隔离级别, Next-key正是用于解决RR隔离级别下的幻象读问题(幻象读: 一个事务执行相同的查询会看到不同的记录);
行锁与间隙锁的合并;
行锁防止别的事务进行修改和删除, 间隙锁防止别的事务新增, 行锁和间隙锁结合解决了RR级别在写数据时的幻象读问题;

假设已有记录为1,2,3,6, 当使用SELECT...WHERE col < 5 FOR UPDATE, 若不在3, 6之间加GAP锁, 另一个进程可能插入一条数据4, 下次执行SELECT...WHERE ... FOR UPDATE时会看到不同的结果;

因此在执行INSERT之前需要判断记录是否加锁;

#LOCK_S(共享锁): 共享锁的作用是在一个事务读取一条记录时, 不希望其被其他的记录更改, 但是所有的读请求的共享锁是不冲突的;
InnoDB中使用请求共享锁的情况: 
1. 普通查询在隔离级别为serializable时会给记录加共享锁(非事务读(auto-commit)在serializable级别下无需加锁);
2. 类似SQL SELECT ... IN SHARE MODE会给记录加共享锁, 其他线程可以并发查询但不能修改; 
3. 通常INSERT不加锁, 但是如果插入或更新记录时检查到duplicate key, 对于普通的INSERT/UPDATE会加共享锁;

#LOCK_X(排他锁): 目的是防止一条记录被并发修改, UPDATE或DELETE或SELECT FOR UPDATE会给记录加排他锁

#通常事务锁在事务提交时被释放, 除以下几种情况:
1. AUTO-INC锁在SQL结束时直接释放
2. 在RC隔离级别执行DML语句时, 从引擎层返回到server的记录若不满足where条件, 立刻unlock;

#并发事务可能带来的问题
1. 更新丢失(Lost Update): 两个或多个事务更新同一条记录, 一个事务的更新覆盖了另一个事务的更新;
2. 脏读(Dirty Reads): 一个事务在对一条记录进行修改, 在这个事务提交之前, 这条记录就处于不一致状态, 当其他事务读取这条记录时, 就读了脏数据;
3. 不可重读(Non-repeatable Reads): A事务读取记录, B事务更新同一条记录, A再次读这条记录时记录已被改变;
4. 幻象读(Phantom Reads): A事务用与之前相同的SQL进行查询, B事务插入了满足其查询条件的记录, A事务发现数据变化了;

#事务的4种隔离级别:

未提交读: 允许脏读, 即可能读取到其他事务未提交的数据;
提交读: 只能读到已提交的数据(Oracle默认级别);
可重复读: 在事务内的查询与事务开始时是一致的;
串行读: 完全串行化, 每次读都需要获得表级共享锁, 读写相互会阻塞;
_______________________________________________________________________________________________
`隔离级别`                    |       `脏读`        |        `不可重读`     |         `幻象读`
未提交读(Read Uncommitted)    |       可能          |         可能          |          可能
已提交读(Read Committed)      |       不可能        |         可能          |           可能
可重复读(Repeatable Read)     |       不可能        |         不可能        |          可能
可串行化(Serializable)        |       不可能        |         不可能        |          不可能
_______________________________________________________________________________________________

`Read Uncommitted`: 一般数据库不会使用;
`Read Committed`: 在RC级别中数据的读是不需要加锁的, 数据的写入修改和更新需要加锁;
`MySql的InnoDB默认是RR级别`, 需要将session开启为RC级别, 并设置binlog的模式;
SET session transcation isolation level read committed;
SET SESSIOIN binlog_format = 'ROW'; (或是MIXED)
`Repeatable Read`: InnoDB默认的隔离级别, '读'是指可重读, 即一个事务的多个实例在并发的读取记录时, 会看到同样的结果;
`Serializable`: 读加共享锁, select都会加锁,  写加排他锁, 读写互斥, 使用了悲观锁的理论, 实现简单, 数据更加安全, 但是`并发能力非常差`, 当业务的并发非常少或没有并发时才使用此模式;

#悲观锁
在整个数据的处理过程中, 数据保持锁定状态, 往往通过数据库提供的锁机制实现(只有数据库层提供的锁机制才能真正的保证数据访问的排他性), 在悲观锁的情况下, 为保证事务的隔离性, 就需要一致性锁定读, 在读取数据时给数据加锁, 修改删除数据也需要加锁;

#乐观锁
悲观锁大多数情况下通过数据库的锁机制实现, 以保证操作最大程度的独占性, 但缺点是数据库的大量开销; 乐观锁在一定程度上解决了这个问题;乐观锁大多基于数据版本(Version)记录机制实现;

