#索引index是提高mysql获取数据效率的数据结构

`mysql InnoDB索引底层数据结构: B+ Tree`

`索引的目的`: 提高查询效率;
`磁盘IO的成本`: 磁盘IO比较耗时(`机械运动消耗`), 磁盘读取依靠机械运动，分为寻道时间，旋转延迟和传输时间，寻道时间是磁臂移动到指定磁道需要的时间，主流磁盘一般在5ms以下；旋转延迟是磁盘转速；传输时间即数据从磁盘读出或写入磁盘的时间，相对与前两个时间这个可以忽略不计。针对这个问题操作系统进行了优化，所以当计算机读取一个地址的数据时, 将相邻的数据也读取到内存中, 每次读取的数据称为一页, 页的大小与操作系统有关;
`索引数据结构`: 目的为降低每次查询数据时的磁盘IO次数 (B+树), IO次数取决于树的高度;
`索引的最左匹配: B+树按照从左到右的顺序建立搜索树`;

#建立索引的原则:
1. `最左匹配原则: mysql会一直右匹配到>, <, between, like就停止匹配`, 例如a=1 and b=2 and c<3 and d=4 `则d用不到索引`;
2. `索引列不能参与计算`: 如from_unixtime(create_time)='2014-01-01'就不能使用索引, 应写成create_time=unix_timestamp('2014-01-01')
3. `=和in可以乱序`, 例如a=1 and b=2 and c=3 建立的(a, b, c)索引可以任意乱序, mysql会自动优化成索引可以识别的形式;
4. 尽量使用扩展索引: 如当前已有索引为a, 若需要(a, b)的索引，只需修改原来的索引;
5. `尽量选择区分度高的列作为索引`: 区分度公式为`COUNT(DISTINCT COL)/COUNT(*)`表示字段不重复的比例，`比例越大扫描的记录数越少`，唯一键的区分度就是1，而一些状态、性别的字段在大数据的情况下区分度可能就是0。一般需要JOIN的字段要求0.1以上，即平均一条索引扫描10条记录;
6. `多个单列索引和组合索引的效果不同，当创建了多个单列索引时，查询优化器会视图选择一个限制最严格(候选记录集数量最小，最有效率)的索引`，`但即使是限制最严格的单列索引，其限制能力也远远低于这些列上的组合索引`;
7. `索引并非越多越好`，因为写入或删除时需要更新索引的信息;

#可以使用索引的SQL:
1. 若字段已建立索引，`求该字段的MAX, MIN时`，依然会使用索引;
2. `对列进行比较`的表达式可以使用索引, 如>=, <, between;
3. 若col_name建立了索引，则`col_name is null`可以使用索引;
4. 若where中不只一个条件，优化器会使用`index merge`进行缩小候选集范围;

`慢查询优化的基本步骤`
0. 设置SQL_NO_CACHE;
1. where单表查, 锁定最小记录返回表, 把查询语句的where应用到表的返回记录最小的表开始查起;
2. explain, 是否与1中的结果一致(从锁定记录最小的表开始查询);
3. order by limit 的sql语句让排序的表优先查;
...

#[高性能MySQL]

`联合索引/复合索引`
联合索引即复合索引, 对于复合索引, `mysql按从左到右的顺序使用索引中的字段`, `查询使用的索引的部分只能是最左的部分`(最左前缀);
例: index(a, b, c)支持a, ab, abc, 但是不支持bc;

`索引的物理存储`
索引本身较大, 不可能全部存储与内存中, 因此索引是`以索引文件的形式存储于磁盘上`;
衡量索引好坏的因素就是查找过程中, 磁盘IO的渐进复杂度, 即`索引的结构组织应尽可能减少查找过程中的磁盘IO次数`;
